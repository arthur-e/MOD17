<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>mod17 API documentation</title>
<meta name="description" content="The MOD17 Daily GPP and Annual GPP algorithm. See `MOD17` for a discussion
of the required model parameters. The required input driver datasets are: …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Package <code>mod17</code></h1>
</header>
<section id="section-intro">
<p>The MOD17 Daily GPP and Annual GPP algorithm. See <code><a title="mod17.MOD17" href="#mod17.MOD17">MOD17</a></code> for a discussion
of the required model parameters. The required input driver datasets are:</p>
<ul>
<li>Daily mean air temperature at 10-meter height (deg C),
e.g., from MERRA-2 <code>T10M</code></li>
<li>Daily minimum air temperature at 10-m height (deg C),
e.g., from MERRA-2 <code>T10M</code></li>
<li>Incident photosynthetically active radiation (PAR) [MJ m-2 day-1),
e.g., from MERRA-2 <code>SWGDN</code>; see also <code><a title="mod17.MOD17.par" href="#mod17.MOD17.par">MOD17.par()</a></code></li>
<li>Vapor pressure deficit (VPD) (Pa), e.g., from MERRA-2 <code>QV10M</code>, <code>T10M</code>, <code>PS</code>;
see also <code><a title="mod17.MOD17.vpd" href="#mod17.MOD17.vpd">MOD17.vpd()</a></code></li>
</ul>
<p>Note that there are two hidden methods of the MOD17 class:</p>
<ul>
<li><code>MOD17._gpp()</code></li>
<li><code>MOD17._npp()</code></li>
</ul>
<p>These are streamlined implementations of <code><a title="mod17.MOD17.daily_gpp" href="#mod17.MOD17.daily_gpp">MOD17.daily_gpp()</a></code> and
<code><a title="mod17.MOD17.annual_npp" href="#mod17.MOD17.annual_npp">MOD17.annual_npp()</a></code>, respectively, and were designed for use in calibration,
where repeated function calls can make function overhead a real issue. These
streamlined functions expect a vectorized parameters array as the first
argument and subsequent arguments are driver datasets, e.g.:</p>
<pre><code>MOD17._gpp(params, fpar, tmin, vpd, par)
MOD17._npp(params, fpar, tmin, vpd, par, lai, tmean, years)
</code></pre>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">r&#39;&#39;&#39;
The MOD17 Daily GPP and Annual GPP algorithm. See `MOD17` for a discussion
of the required model parameters. The required input driver datasets are:

- Daily mean air temperature at 10-meter height (deg C),
    e.g., from MERRA-2 `T10M`
- Daily minimum air temperature at 10-m height (deg C),
    e.g., from MERRA-2 `T10M`
- Incident photosynthetically active radiation (PAR) [MJ m-2 day-1),
    e.g., from MERRA-2 `SWGDN`; see also `MOD17.par()`
- Vapor pressure deficit (VPD) (Pa), e.g., from MERRA-2 `QV10M`, `T10M`, `PS`;
    see also `MOD17.vpd()`

Note that there are two hidden methods of the MOD17 class:

- `MOD17._gpp()`
- `MOD17._npp()`

These are streamlined implementations of `MOD17.daily_gpp()` and
`MOD17.annual_npp()`, respectively, and were designed for use in calibration,
where repeated function calls can make function overhead a real issue. These
streamlined functions expect a vectorized parameters array as the first
argument and subsequent arguments are driver datasets, e.g.:

    MOD17._gpp(params, fpar, tmin, vpd, par)
    MOD17._npp(params, fpar, tmin, vpd, par, lai, tmean, years)
&#39;&#39;&#39;

import warnings
import numpy as np
from typing import Callable, Sequence, Tuple, Union, Iterable
from numbers import Number

PFT_VALID = (1,2,3,4,5,6,7,8,9,10,12)

class MOD17(object):
    &#39;&#39;&#39;
    The MODIS MxD17 Gross Primary Productivity and Net Photosynthesis model.
    The required model parameters are:

    - `LUE_max`: Maximum light-use efficiency (kg C MJ-1)
    - `tmin0` and `tmin1`: The lower and upper bounds on the temperature
        response of photosynthesis (deg C); i.e., temperature at which stomata
        are fully closed and fully open, respectively
    - `vpd0` and `vpd0`: The lower and upper bounds on the response to VPD
        of photosynthesis (Pa); i.e., VPD at which stomata are full open and
        fully closed, respectively
    - `SLA`: Specific leaf area, or projected leaf area per kilogram of C
        [LAI kg C-1]
    - `q10`: Exponent shape parameter controlling respiration as a function of
        temperature (in degrees C) (unitless)
    - `froot_leaf_ratio`: The ratio of fine root C to leaf C (unitless).
    - `livewood_leaf_ratio`: Ratio of live wood carbon to annual maximum leaf
        carbon
    - `leaf_mr_base`: Maintenance respiration per unit leaf carbon per day at
        a reference temperature of 20 degrees C [kg C (kg C)-1 day-1]
    - `froot_mr_base`: Maintenance respiration per unit fine root carbon per
        day at a reference temperature of 20 degrees C [kg C (kg C)-1 day-1]
    - `livewood_mr_base`: Maintenance respiration per unit live wood carbon
        per day at a reference temperature of 20 degrees C [kg C (kg C)-1 d-1]

    NOTE: This class includes private class methods `MOD17._gpp()` and
    `MOD17._gpp()`, that avoid the overhead associated with creating a model
    instance; it should be used, e.g., for model calibration because it is faster
    and produces the same results as `MOD17.daily_gpp()`.

    NOTE: For multiple PFTs, vectorized parameters array can be passed; i.e.,
    a dictionary where each value is an (N,) array for N sites.

    Parameters
    ----------
    params : dict
        Dictionary of model parameters
    &#39;&#39;&#39;
    required_parameters = [
        &#39;LUE_max&#39;, &#39;tmin0&#39;, &#39;tmin1&#39;, &#39;vpd0&#39;, &#39;vpd1&#39;, &#39;SLA&#39;,
        &#39;Q10_livewood&#39;, &#39;Q10_froot&#39;, &#39;froot_leaf_ratio&#39;,
        &#39;livewood_leaf_ratio&#39;, &#39;leaf_mr_base&#39;, &#39;froot_mr_base&#39;,
        &#39;livewood_mr_base&#39;
    ]

    def __init__(self, params: dict):
        self.params = params
        for key in self.required_parameters:
            setattr(self, key, params[key])

    @staticmethod
    def _gpp(params, fpar, tmin, vpd, par):
        &#39;Daily GPP as static method, avoids overhead of class instantiation&#39;
        # &#34;params&#34; argument should be a Sequence of atomic parameter values
        #   in the order prescribed by &#34;required_parameters&#34;
        tmin_scalar = linear_constraint(params[1], params[2])(tmin)
        vpd_scalar = linear_constraint(
            params[3], params[4], form = &#39;reversed&#39;)(vpd)
        lue = params[0] * tmin_scalar * vpd_scalar
        return 1e3 * lue * fpar * par

    @staticmethod
    def _npp(params, fpar, tmin, vpd, par, lai, tmean, years):
        &#39;&#39;&#39;
        Annual NPP as static method, avoids overhead of class instantiation.
        NOTE: It&#39;s assumed that the elements of `years` are in chronological
        order on the first axis (time axis).
        &#39;&#39;&#39;
        # &#34;params&#34; argument should be a Sequence of atomic parameter values
        #   in the order prescribed by &#34;required_parameters&#34;
        gpp = MOD17._gpp(params, fpar, tmin, vpd, par)
        # Daily respiration
        leaf_mass = lai / params[5] # LAI divided by SLA -&gt; leaf mass [kg m-2]
        froot_mass = leaf_mass * params[8] # Leaf mass times `froot_leaf_ratio`
        # NOTE: Q10 calculated differently depending on the component
        _exp = (tmean - 20) / 10
        q10_leaf = np.power(3.22 - 0.046 * tmean, _exp)
        q10_froot = np.power(params[7], _exp)
        # Convert leaf, froot mass from [kg C m-2] to [g C m-2], then...
        r_leaf = 1e3 * leaf_mass * params[10] * q10_leaf
        r_froot = 1e3 * froot_mass * params[11] * q10_froot
        # Accumulate respiration over each year
        all_years = np.unique(years).tolist()
        # Pre-allocate arrays
        mr_leaf = np.full((len(all_years), *lai.shape[1:],), np.nan)
        mr_froot = np.full((len(all_years), *lai.shape[1:],), np.nan)
        mr_livewood = np.full((len(all_years), *lai.shape[1:],), np.nan)
        diff = np.full((len(all_years), *lai.shape[1:],), np.nan)
        for i, each_year in enumerate(all_years):
            # Sum respiration for each tissue in each year
            mr_leaf[i] = np.nansum(
                np.where(years == each_year, r_leaf, 0), axis = 0)
            mr_froot[i] = np.nansum(
                np.where(years == each_year, r_froot, 0), axis = 0)
            livewood_mass = (np.nanmax(
                np.where(years == each_year, lai, np.nan), axis = 0
                ) / params[5]
            ) * params[9]
            # For consistency with other respiration components, livewood
            #   respiration should be zero, not NaN, when no respiration
            mrl = 1e3 * livewood_mass * params[12] *\
                np.power(params[6], (tmean - 20) / 10).sum(axis = 0)
            mr_livewood[i] = np.where(np.isnan(mrl), 0, mrl)
            # Total plant maintenance respiration
            r_m = mr_leaf[i] + mr_froot[i] + mr_livewood[i]
            # GPP - R_M
            diff[i] =  np.where(years == each_year, gpp, 0).sum(axis = 0) - r_m
        # Annual growth respiration is assumed to be 25% of (GPP - R_M); see
        #   Figure 1 of MOD17 User Guide; the User Guide is TOO CUTE about
        #   derivation; 0.8 == (1/1.25), hence the &#34;25%&#34; figure
        return np.where(diff &lt; 0, 0, 0.8 * diff)

    @staticmethod
    def par(sw_rad: Number, period_hrs: Number = 1) -&gt; Number:
        &#39;&#39;&#39;
        Calculates daily total photosynthetically active radiation (PAR) from
        (hourly) incoming short-wave radiation (SW_rad). PAR is assumed to
        be 45% of SW_rad.

        Parameters
        ----------
        swrad : int or float or numpy.ndarray
            Incoming short-wave radiation (W m-2)
        period_hrs : int
            Period over which radiation is measured, in hours (Default: 1)

        Returns
        -------
        int or float or numpy.ndarray
        &#39;&#39;&#39;
        # Convert SW_rad from [W m-2] to [MJ m-2], then take 45%;
        #   3600 secs hr-1 times (1 MJ / 1e6 Joules) == 0.0036
        return 0.45 * (0.0036 * (24 / period_hrs) * sw_rad)

    @staticmethod
    def vpd(qv10m: Number, pressure: Number, tmean: Number) -&gt; Number:
        &#39;&#39;&#39;
        Computes vapor pressure deficit (VPD) from surface meteorology.

        Parameters
        ----------
        qv10m : int or float or numpy.ndarray
            Water vapor mixing ratio at 10-meter height (Pa)
        pressure : int or float or numpy.ndarray
            Atmospheric pressure (Pa)
        tmean : int or float or numpy.ndarray
            Mean daytime temperature (degrees C)

        Returns
        -------
        int or float or numpy.ndarray
        &#39;&#39;&#39;
        # Actual vapor pressure (Gates 1980, Biophysical Ecology, p.311)
        avp = (qv10m * pressure) / (0.622 + (0.379 * qv10m))
        # Saturation vapor pressure (similar to FAO formula)
        svp = 610.7 * np.exp((17.38 * tmean) / (239 + tmean))
        return svp - avp

    def annual_npp(
            self, fpar: Sequence, tmin: Sequence, vpd: Sequence,
            par: Sequence, lai: Sequence, tmean: Sequence, years: Sequence
            ) -&gt; np.ndarray:
        &#39;&#39;&#39;
        Annual net primary productivity (NPP).

        Parameters
        ----------
        fpar : Sequence
            Fraction of PAR intercepted by the canopy [0, 1], a (T x ...)
            array for T number of days
        tmin : Sequence
            Daily minimum temperature (degrees C), a (T x ...) array for T
            number of days
        vpd : Sequence
            Daytime vapor pressure deficit (Pa), a (T x ...) array for T
            number of days
        par : Sequence
            Daily photosynthetically active radation (MJ m-2 day-1)
        lai : Sequence
            Leaf area index, daily, a (T x ...) array for T number of days
        tmean : Sequence
            Mean daily temperature (degrees C), a (T x ...) array for T number
            of days
        years : Sequence
            Sequence of integers indicating the year of each daily
            measurement, in order (e.g., [2015, 2015, ..., 2017]); a (T x ...)
            array for T number of days

        Returns
        -------
        numpy.ndarray
            Total annual NPP [g C m-2 year-1]
        &#39;&#39;&#39;
        r_leaf, r_froot, r_livewood = self.annual_respiration(
            lai, tmean, years)
        r_m = r_leaf + r_froot + r_livewood
        gpp = self.daily_gpp(fpar, tmin, vpd, par)
        diff = np.empty(r_m.shape)
        all_years = np.unique(years).tolist()
        for i, each_year in enumerate(all_years):
            # GPP - R_M
            diff[i] = np.where(years == each_year, gpp, 0).sum(axis = 0) - r_m[i]
        return np.where(diff &lt; 0, 0, 0.8 * diff)

    def annual_respiration(
            self, lai: Sequence, tmean: Sequence, years: Sequence
            ) -&gt; Iterable[Tuple[Sequence, Sequence, Sequence]]:
        &#39;&#39;&#39;
        Annual total maintenance respiration. Input datasets should have daily
        denominations and extend over one or more years.

        Parameters
        ----------
        lai : Sequence
            Leaf area index, daily, a (T x ...) array for T number of days
        tmean : Sequence
            Mean daily temperature (degrees C), a (T x ...) array for T number
            of days
        years : Sequence
            Sequence of integers indicating the year of each daily
            measurement, in order (e.g., [2015, 2015, ..., 2017]); a (T x ...)
            array for T number of days

        Returns
        -------
        tuple
            A 3-tuple of total annual (leaf, fine root, livewood) respiration
            with units of [g C m-2 year-1]
        &#39;&#39;&#39;
        assert lai.shape == years.shape,\
            &#39;LAI array should conform with &#34;years&#34; array&#39;
        assert tmean.shape == years.shape,\
            &#39;Mean temperature array should conform with &#34;years&#34; array&#39;
        r_leaf_daily, r_froot_daily = self.daily_respiration(lai, tmean)
        r_leaf, r_froot, r_livewood = [], [], []
        all_years = np.unique(years).tolist()
        all_years.sort()
        for i, each_year in enumerate(all_years):
            r_leaf.append(
                np.nansum(np.where(years == each_year, r_leaf_daily, 0),
                axis = 0))
            r_froot.append(
                np.nansum(np.where(years == each_year, r_froot_daily, 0),
                axis = 0))
            # Annual maximum leaf mass (kg C) converted to livewood mass
            #   by allometric relation (livewood_leaf_ratio)
            livewood_mass = (np.nanmax(
                    np.where(years == each_year, lai, np.nan), axis = 0
                ) / self.SLA) * self.livewood_leaf_ratio
            # Livewood maintenance respiration (g C day-1), converted from
            #   (kg C day-1), as the product of livewood_mass, base
            #   respiration rate (livewood_mr_base), and annual sum of the
            #   maint. respiration term (Q10), see Equation 1.10, User&#39;s Guide
            # NOTE: &#34;livewood_mr_base&#34; is denominated in days
            #   (kg C kg C-1 day-1) but that&#39;s okay because we took the annual
            #   sum of the Q10 respiration, essentially multipling by ~365
            rl = 1e3 * livewood_mass * self.livewood_mr_base *\
                np.power(self.Q10_livewood, (tmean - 20) / 10).sum(axis = 0)
            # For consistency with other respiration components, livewood
            #   respiration should be zero, not NaN, when no respiration
            r_livewood.append(np.where(np.isnan(rl), 0, rl))
        return (np.stack(r_leaf), np.stack(r_froot), np.vstack(r_livewood))

    def daily_gpp(
            self, fpar: Number, tmin: Number, vpd: Number,
            par: Number) -&gt; Number:
        r&#39;&#39;&#39;
        Daily gross primary productivity (GPP).

        $$
        \mathrm{GPP} = \varepsilon\times f(T_{min})\times f(V)\times
            [\mathrm{PAR}]\times [\mathrm{fPAR}]
        $$

        Where \(T_{min}\) is the minimum daily temperature, \(V\) is the
        daytime vapor pressure deficit (VPD), PAR is daily photosynthetically
        active radiation, fPAR is the fraction of PAR absorbed by the canopy,
        and \(\varepsilon\) is the intrinsic (or maximum) light-use efficiency.

        Parameters
        ----------
        fpar : int or float or numpy.ndarray
            Fraction of PAR intercepted by the canopy [0, 1]
        tmin : int or float or numpy.ndarray
            Daily minimum temperature (degrees C)
        vpd : int or float or numpy.ndarray
            Daytime vapor pressure deficit (Pa)
        par : int or float or numpy.ndarray
            Daily photosynthetically active radation (MJ m-2 day-1)

        Returns
        -------
        int or float or numpy.ndarray
            Daily GPP flux in [g C m-2 day-1]
        &#39;&#39;&#39;
        return 1e3 * self.lue(tmin, vpd) * fpar * par

    def daily_respiration(
            self, lai: Number, tmean: Number
            ) -&gt; Iterable[Tuple[Number, Number]]:
        r&#39;&#39;&#39;
        Daily maintenance respiration for leaves and fine roots.

        Maintenance respiration, \(r_m\), for leaves or fine roots is given:

        $$
        r_m = m \times r_0 \times q^{\frac{T - 20}{10}}
        $$

        Where \(m\) is either the leaf mass or fine root mass; \(r_0\) is the rate
        of maintenance respiration per unit leaf carbon (per day, at 20
        degrees C); and \(q\) is the Q10 factor.

        NOTE: For fine roots and live wood, Q10 is a constant value of 2.0.
        For leaves, the temperature-acclimated Q10 equation of Tjoelker et al.
        (2001, Global Change Biology) is used:

        $$
        Q_{10} = 3.22 - 0.046 * T_{avg}
        $$

        The &#34;net photosynthesis&#34; quantity in MOD17, even though it is a bit
        misleading (it does not account for growth respiration and livewood
        \(r_m\) can then be calculated as GPP less the maintenance respiration
        of leaves and fine roots:

        $$
        P_{net} = [\mathrm{GPP}] - r_{leaf} - r_{root}
        $$

        Parameters
        ----------
        lai : float or numpy.ndarray
            Leaf area index, daily
        tmean : float or numpy.ndarray
            Mean daily temperature (degrees C)

        Returns
        -------
        tuple
            2-element tuple of (leaf respiration, fine root respiration) in
            units of [g C m-2 day-1]
        &#39;&#39;&#39;
        # Leaf mass, fine root mass (Eq 1.4, 1.5 in MOD17 User Guide)
        leaf_mass = lai / self.SLA
        froot_mass = leaf_mass * self.froot_leaf_ratio
        # NOTE: Q10 calculated differently depending on the component
        _exp = (tmean - 20) / 10 # Equations 1.6 and 1.7
        q10_leaf = np.power(3.22 - 0.046 * tmean, _exp) # Equation 1.11
        q10_froot = np.power(self.Q10_froot, _exp)
        # NOTE: Converting from [kg C] to [g C] via *1e3
        r_leaf = 1e3 * leaf_mass * self.leaf_mr_base * q10_leaf
        r_froot = 1e3 * froot_mass * self.froot_mr_base * q10_froot
        return (r_leaf, r_froot)

    def daily_net_photosynthesis(
            self, fpar: Number, tmin: Number, vpd: Number, par: Number,
            lai: Number, tmean: Number) -&gt; Number:
        &#39;&#39;&#39;
        Daily net photosynthesis (&#34;PSNet&#34;). See:

        - `MOD17.daily_gpp()`
        - `MOD17.daily_respiration()`

        Parameters
        ----------
        fpar : int or float or numpy.ndarray
            Fraction of PAR intercepted by the canopy [0, 1]
        tmin : int or float or numpy.ndarray
            Daily minimum temperature (degrees C)
        vpd : int or float or numpy.ndarray
            Daytime vapor pressure deficit (Pa)
        par : int or float or numpy.ndarray
            Daily photosynthetically active radation (MJ m-2 day-1)
        lai : float or numpy.ndarray
            Leaf area index, daily
        tmean : float or numpy.ndarray
            Mean daily temperature (degrees C)
        &#39;&#39;&#39;
        gpp = self.daily_gpp(fpar, tmin, vpd, par)
        r_leaf, r_froot = self.daily_respiration(lai, tmean)
        # See MOD17 User Gudie, Equation 1.8
        return gpp - r_leaf - r_froot

    def lue(self, tmin: Number, vpd: Number) -&gt; Number:
        &#39;&#39;&#39;
        The instantaneous light-use efficiency (LUE), reduced by environmental
        stressors (low minimum temperature, high VPD) from the maximum LUE.

        Parameters
        ----------
        tmin : int or float or numpy.ndarray
        vpd : int or float or numpy.ndarray

        Returns
        -------
        float or numpy.ndarray
        &#39;&#39;&#39;
        return self.LUE_max * self.tmin_scalar(tmin) * self.vpd_scalar(vpd)

    def tmin_scalar(self, x: Number) -&gt; Number:
        &#39;&#39;&#39;
        Parameters
        ----------
        x : int or float or numpy.ndarray
            Minimum temperature (deg C)

        Returns
        -------
        int or float or numpy.ndarray
        &#39;&#39;&#39;
        return linear_constraint(self.tmin0, self.tmin1)(x)

    def vpd_scalar(self, x: Number) -&gt; Number:
        &#39;&#39;&#39;
        The environmental scalar for vapor pressure deficit (VPD).

        Parameters
        ----------
        x : int or float or numpy.ndarray
            Vapor pressure deficit (Pa)

        Returns
        -------
        int or float or numpy.ndarray
        &#39;&#39;&#39;
        return linear_constraint(self.vpd0, self.vpd1, form = &#39;reversed&#39;)(x)


def linear_constraint(
        xmin: Number, xmax: Number, form: str = None) -&gt; Callable:
    &#39;&#39;&#39;
    Returns a linear ramp function, for deriving a value on [0, 1] from
    an input value `x`:

        if x &gt;= xmax:
            return 1
        if x &lt;= xmin:
            return 0
        return (x - xmin) / (xmax - xmin)

    Parameters
    ----------
    xmin : int or float
        Lower bound of the linear ramp function
    xmax : int or float
        Upper bound of the linear ramp function
    form : str
        Type of ramp function: &#34;reversed&#34; decreases as x increases;
        &#34;binary&#34; returns xmax when x == 1; default (None) is increasing
        as x increases.

    Returns
    -------
    function
    &#39;&#39;&#39;
    assert form is None or form in (&#39;reversed&#39;, &#39;binary&#39;),\
        &#39;Argument &#34;form&#34; must be None or one of: &#34;reversed&#34;, &#34;binary&#34;&#39;
    assert form == &#39;binary&#39; or np.any(xmax &gt;= xmin),\
        &#39;xmax must be greater than/ equal to xmin&#39;
    if form == &#39;reversed&#39;:
        return lambda x: np.where(x &gt;= xmax, 0,
            np.where(x &lt; xmin, 1, 1 - np.divide(
                np.subtract(x, xmin), xmax - xmin)))
    if form == &#39;binary&#39;:
        return lambda x: np.where(x == 1, xmax, xmin)
    return lambda x: np.where(x &gt;= xmax, 1,
        np.where(x &lt; xmin, 0,
            np.divide(np.subtract(x, xmin), xmax - xmin)))


def suppress_warnings(func):
    &#39;Decorator to suppress NumPy warnings&#39;
    def inner(*args, **kwargs):
        with warnings.catch_warnings():
            warnings.simplefilter(&#39;ignore&#39;)
            return func(*args, **kwargs)
    return inner</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="mod17.calibration" href="calibration.html">mod17.calibration</a></code></dt>
<dd>
<div class="desc"><p>Calibration of MOD17 against a representative, global eddy covariance (EC)
flux tower network. The model calibration is based on Markov-Chain Monte
…</p></div>
</dd>
<dt><code class="name"><a title="mod17.science" href="science.html">mod17.science</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="mod17.sensitivity" href="sensitivity.html">mod17.sensitivity</a></code></dt>
<dd>
<div class="desc"><p>Performs the Sobol' sensitivity analysis for the MOD17 GPP and NPP models …</p></div>
</dd>
<dt><code class="name"><a title="mod17.srs" href="srs.html">mod17.srs</a></code></dt>
<dd>
<div class="desc"><p>MODIS sinusoidal projection forward and backward coordinate transformations,
courtesy of Giglio et al. (2018), Collection 6 MODIS Burned Area Product
…</p></div>
</dd>
<dt><code class="name"><a title="mod17.utils" href="utils.html">mod17.utils</a></code></dt>
<dd>
<div class="desc"><p>Utilities related to the MOD17 algorithm.</p></div>
</dd>
<dt><code class="name"><a title="mod17.viirs" href="viirs.html">mod17.viirs</a></code></dt>
<dd>
<div class="desc"><p>Calibration of MOD17 against a representative, global eddy covariance (EC)
flux tower network. The model calibration is based on Markov-Chain Monte
…</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="mod17.linear_constraint"><code class="name flex">
<span>def <span class="ident">linear_constraint</span></span>(<span>xmin: numbers.Number, xmax: numbers.Number, form: str = None) ‑> Callable</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a linear ramp function, for deriving a value on [0, 1] from
an input value <code>x</code>:</p>
<pre><code>if x &gt;= xmax:
    return 1
if x &lt;= xmin:
    return 0
return (x - xmin) / (xmax - xmin)
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>xmin</code></strong> :&ensp;<code>int</code> or <code>float</code></dt>
<dd>Lower bound of the linear ramp function</dd>
<dt><strong><code>xmax</code></strong> :&ensp;<code>int</code> or <code>float</code></dt>
<dd>Upper bound of the linear ramp function</dd>
<dt><strong><code>form</code></strong> :&ensp;<code>str</code></dt>
<dd>Type of ramp function: "reversed" decreases as x increases;
"binary" returns xmax when x == 1; default (None) is increasing
as x increases.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>function</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def linear_constraint(
        xmin: Number, xmax: Number, form: str = None) -&gt; Callable:
    &#39;&#39;&#39;
    Returns a linear ramp function, for deriving a value on [0, 1] from
    an input value `x`:

        if x &gt;= xmax:
            return 1
        if x &lt;= xmin:
            return 0
        return (x - xmin) / (xmax - xmin)

    Parameters
    ----------
    xmin : int or float
        Lower bound of the linear ramp function
    xmax : int or float
        Upper bound of the linear ramp function
    form : str
        Type of ramp function: &#34;reversed&#34; decreases as x increases;
        &#34;binary&#34; returns xmax when x == 1; default (None) is increasing
        as x increases.

    Returns
    -------
    function
    &#39;&#39;&#39;
    assert form is None or form in (&#39;reversed&#39;, &#39;binary&#39;),\
        &#39;Argument &#34;form&#34; must be None or one of: &#34;reversed&#34;, &#34;binary&#34;&#39;
    assert form == &#39;binary&#39; or np.any(xmax &gt;= xmin),\
        &#39;xmax must be greater than/ equal to xmin&#39;
    if form == &#39;reversed&#39;:
        return lambda x: np.where(x &gt;= xmax, 0,
            np.where(x &lt; xmin, 1, 1 - np.divide(
                np.subtract(x, xmin), xmax - xmin)))
    if form == &#39;binary&#39;:
        return lambda x: np.where(x == 1, xmax, xmin)
    return lambda x: np.where(x &gt;= xmax, 1,
        np.where(x &lt; xmin, 0,
            np.divide(np.subtract(x, xmin), xmax - xmin)))</code></pre>
</details>
</dd>
<dt id="mod17.suppress_warnings"><code class="name flex">
<span>def <span class="ident">suppress_warnings</span></span>(<span>func)</span>
</code></dt>
<dd>
<div class="desc"><p>Decorator to suppress NumPy warnings</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def suppress_warnings(func):
    &#39;Decorator to suppress NumPy warnings&#39;
    def inner(*args, **kwargs):
        with warnings.catch_warnings():
            warnings.simplefilter(&#39;ignore&#39;)
            return func(*args, **kwargs)
    return inner</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="mod17.MOD17"><code class="flex name class">
<span>class <span class="ident">MOD17</span></span>
<span>(</span><span>params: dict)</span>
</code></dt>
<dd>
<div class="desc"><p>The MODIS MxD17 Gross Primary Productivity and Net Photosynthesis model.
The required model parameters are:</p>
<ul>
<li><code>LUE_max</code>: Maximum light-use efficiency (kg C MJ-1)</li>
<li><code>tmin0</code> and <code>tmin1</code>: The lower and upper bounds on the temperature
response of photosynthesis (deg C); i.e., temperature at which stomata
are fully closed and fully open, respectively</li>
<li><code>vpd0</code> and <code>vpd0</code>: The lower and upper bounds on the response to VPD
of photosynthesis (Pa); i.e., VPD at which stomata are full open and
fully closed, respectively</li>
<li><code>SLA</code>: Specific leaf area, or projected leaf area per kilogram of C
[LAI kg C-1]</li>
<li><code>q10</code>: Exponent shape parameter controlling respiration as a function of
temperature (in degrees C) (unitless)</li>
<li><code>froot_leaf_ratio</code>: The ratio of fine root C to leaf C (unitless).</li>
<li><code>livewood_leaf_ratio</code>: Ratio of live wood carbon to annual maximum leaf
carbon</li>
<li><code>leaf_mr_base</code>: Maintenance respiration per unit leaf carbon per day at
a reference temperature of 20 degrees C [kg C (kg C)-1 day-1]</li>
<li><code>froot_mr_base</code>: Maintenance respiration per unit fine root carbon per
day at a reference temperature of 20 degrees C [kg C (kg C)-1 day-1]</li>
<li><code>livewood_mr_base</code>: Maintenance respiration per unit live wood carbon
per day at a reference temperature of 20 degrees C [kg C (kg C)-1 d-1]</li>
</ul>
<p>NOTE: This class includes private class methods <code>MOD17._gpp()</code> and
<code>MOD17._gpp()</code>, that avoid the overhead associated with creating a model
instance; it should be used, e.g., for model calibration because it is faster
and produces the same results as <code><a title="mod17.MOD17.daily_gpp" href="#mod17.MOD17.daily_gpp">MOD17.daily_gpp()</a></code>.</p>
<p>NOTE: For multiple PFTs, vectorized parameters array can be passed; i.e.,
a dictionary where each value is an (N,) array for N sites.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>params</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary of model parameters</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MOD17(object):
    &#39;&#39;&#39;
    The MODIS MxD17 Gross Primary Productivity and Net Photosynthesis model.
    The required model parameters are:

    - `LUE_max`: Maximum light-use efficiency (kg C MJ-1)
    - `tmin0` and `tmin1`: The lower and upper bounds on the temperature
        response of photosynthesis (deg C); i.e., temperature at which stomata
        are fully closed and fully open, respectively
    - `vpd0` and `vpd0`: The lower and upper bounds on the response to VPD
        of photosynthesis (Pa); i.e., VPD at which stomata are full open and
        fully closed, respectively
    - `SLA`: Specific leaf area, or projected leaf area per kilogram of C
        [LAI kg C-1]
    - `q10`: Exponent shape parameter controlling respiration as a function of
        temperature (in degrees C) (unitless)
    - `froot_leaf_ratio`: The ratio of fine root C to leaf C (unitless).
    - `livewood_leaf_ratio`: Ratio of live wood carbon to annual maximum leaf
        carbon
    - `leaf_mr_base`: Maintenance respiration per unit leaf carbon per day at
        a reference temperature of 20 degrees C [kg C (kg C)-1 day-1]
    - `froot_mr_base`: Maintenance respiration per unit fine root carbon per
        day at a reference temperature of 20 degrees C [kg C (kg C)-1 day-1]
    - `livewood_mr_base`: Maintenance respiration per unit live wood carbon
        per day at a reference temperature of 20 degrees C [kg C (kg C)-1 d-1]

    NOTE: This class includes private class methods `MOD17._gpp()` and
    `MOD17._gpp()`, that avoid the overhead associated with creating a model
    instance; it should be used, e.g., for model calibration because it is faster
    and produces the same results as `MOD17.daily_gpp()`.

    NOTE: For multiple PFTs, vectorized parameters array can be passed; i.e.,
    a dictionary where each value is an (N,) array for N sites.

    Parameters
    ----------
    params : dict
        Dictionary of model parameters
    &#39;&#39;&#39;
    required_parameters = [
        &#39;LUE_max&#39;, &#39;tmin0&#39;, &#39;tmin1&#39;, &#39;vpd0&#39;, &#39;vpd1&#39;, &#39;SLA&#39;,
        &#39;Q10_livewood&#39;, &#39;Q10_froot&#39;, &#39;froot_leaf_ratio&#39;,
        &#39;livewood_leaf_ratio&#39;, &#39;leaf_mr_base&#39;, &#39;froot_mr_base&#39;,
        &#39;livewood_mr_base&#39;
    ]

    def __init__(self, params: dict):
        self.params = params
        for key in self.required_parameters:
            setattr(self, key, params[key])

    @staticmethod
    def _gpp(params, fpar, tmin, vpd, par):
        &#39;Daily GPP as static method, avoids overhead of class instantiation&#39;
        # &#34;params&#34; argument should be a Sequence of atomic parameter values
        #   in the order prescribed by &#34;required_parameters&#34;
        tmin_scalar = linear_constraint(params[1], params[2])(tmin)
        vpd_scalar = linear_constraint(
            params[3], params[4], form = &#39;reversed&#39;)(vpd)
        lue = params[0] * tmin_scalar * vpd_scalar
        return 1e3 * lue * fpar * par

    @staticmethod
    def _npp(params, fpar, tmin, vpd, par, lai, tmean, years):
        &#39;&#39;&#39;
        Annual NPP as static method, avoids overhead of class instantiation.
        NOTE: It&#39;s assumed that the elements of `years` are in chronological
        order on the first axis (time axis).
        &#39;&#39;&#39;
        # &#34;params&#34; argument should be a Sequence of atomic parameter values
        #   in the order prescribed by &#34;required_parameters&#34;
        gpp = MOD17._gpp(params, fpar, tmin, vpd, par)
        # Daily respiration
        leaf_mass = lai / params[5] # LAI divided by SLA -&gt; leaf mass [kg m-2]
        froot_mass = leaf_mass * params[8] # Leaf mass times `froot_leaf_ratio`
        # NOTE: Q10 calculated differently depending on the component
        _exp = (tmean - 20) / 10
        q10_leaf = np.power(3.22 - 0.046 * tmean, _exp)
        q10_froot = np.power(params[7], _exp)
        # Convert leaf, froot mass from [kg C m-2] to [g C m-2], then...
        r_leaf = 1e3 * leaf_mass * params[10] * q10_leaf
        r_froot = 1e3 * froot_mass * params[11] * q10_froot
        # Accumulate respiration over each year
        all_years = np.unique(years).tolist()
        # Pre-allocate arrays
        mr_leaf = np.full((len(all_years), *lai.shape[1:],), np.nan)
        mr_froot = np.full((len(all_years), *lai.shape[1:],), np.nan)
        mr_livewood = np.full((len(all_years), *lai.shape[1:],), np.nan)
        diff = np.full((len(all_years), *lai.shape[1:],), np.nan)
        for i, each_year in enumerate(all_years):
            # Sum respiration for each tissue in each year
            mr_leaf[i] = np.nansum(
                np.where(years == each_year, r_leaf, 0), axis = 0)
            mr_froot[i] = np.nansum(
                np.where(years == each_year, r_froot, 0), axis = 0)
            livewood_mass = (np.nanmax(
                np.where(years == each_year, lai, np.nan), axis = 0
                ) / params[5]
            ) * params[9]
            # For consistency with other respiration components, livewood
            #   respiration should be zero, not NaN, when no respiration
            mrl = 1e3 * livewood_mass * params[12] *\
                np.power(params[6], (tmean - 20) / 10).sum(axis = 0)
            mr_livewood[i] = np.where(np.isnan(mrl), 0, mrl)
            # Total plant maintenance respiration
            r_m = mr_leaf[i] + mr_froot[i] + mr_livewood[i]
            # GPP - R_M
            diff[i] =  np.where(years == each_year, gpp, 0).sum(axis = 0) - r_m
        # Annual growth respiration is assumed to be 25% of (GPP - R_M); see
        #   Figure 1 of MOD17 User Guide; the User Guide is TOO CUTE about
        #   derivation; 0.8 == (1/1.25), hence the &#34;25%&#34; figure
        return np.where(diff &lt; 0, 0, 0.8 * diff)

    @staticmethod
    def par(sw_rad: Number, period_hrs: Number = 1) -&gt; Number:
        &#39;&#39;&#39;
        Calculates daily total photosynthetically active radiation (PAR) from
        (hourly) incoming short-wave radiation (SW_rad). PAR is assumed to
        be 45% of SW_rad.

        Parameters
        ----------
        swrad : int or float or numpy.ndarray
            Incoming short-wave radiation (W m-2)
        period_hrs : int
            Period over which radiation is measured, in hours (Default: 1)

        Returns
        -------
        int or float or numpy.ndarray
        &#39;&#39;&#39;
        # Convert SW_rad from [W m-2] to [MJ m-2], then take 45%;
        #   3600 secs hr-1 times (1 MJ / 1e6 Joules) == 0.0036
        return 0.45 * (0.0036 * (24 / period_hrs) * sw_rad)

    @staticmethod
    def vpd(qv10m: Number, pressure: Number, tmean: Number) -&gt; Number:
        &#39;&#39;&#39;
        Computes vapor pressure deficit (VPD) from surface meteorology.

        Parameters
        ----------
        qv10m : int or float or numpy.ndarray
            Water vapor mixing ratio at 10-meter height (Pa)
        pressure : int or float or numpy.ndarray
            Atmospheric pressure (Pa)
        tmean : int or float or numpy.ndarray
            Mean daytime temperature (degrees C)

        Returns
        -------
        int or float or numpy.ndarray
        &#39;&#39;&#39;
        # Actual vapor pressure (Gates 1980, Biophysical Ecology, p.311)
        avp = (qv10m * pressure) / (0.622 + (0.379 * qv10m))
        # Saturation vapor pressure (similar to FAO formula)
        svp = 610.7 * np.exp((17.38 * tmean) / (239 + tmean))
        return svp - avp

    def annual_npp(
            self, fpar: Sequence, tmin: Sequence, vpd: Sequence,
            par: Sequence, lai: Sequence, tmean: Sequence, years: Sequence
            ) -&gt; np.ndarray:
        &#39;&#39;&#39;
        Annual net primary productivity (NPP).

        Parameters
        ----------
        fpar : Sequence
            Fraction of PAR intercepted by the canopy [0, 1], a (T x ...)
            array for T number of days
        tmin : Sequence
            Daily minimum temperature (degrees C), a (T x ...) array for T
            number of days
        vpd : Sequence
            Daytime vapor pressure deficit (Pa), a (T x ...) array for T
            number of days
        par : Sequence
            Daily photosynthetically active radation (MJ m-2 day-1)
        lai : Sequence
            Leaf area index, daily, a (T x ...) array for T number of days
        tmean : Sequence
            Mean daily temperature (degrees C), a (T x ...) array for T number
            of days
        years : Sequence
            Sequence of integers indicating the year of each daily
            measurement, in order (e.g., [2015, 2015, ..., 2017]); a (T x ...)
            array for T number of days

        Returns
        -------
        numpy.ndarray
            Total annual NPP [g C m-2 year-1]
        &#39;&#39;&#39;
        r_leaf, r_froot, r_livewood = self.annual_respiration(
            lai, tmean, years)
        r_m = r_leaf + r_froot + r_livewood
        gpp = self.daily_gpp(fpar, tmin, vpd, par)
        diff = np.empty(r_m.shape)
        all_years = np.unique(years).tolist()
        for i, each_year in enumerate(all_years):
            # GPP - R_M
            diff[i] = np.where(years == each_year, gpp, 0).sum(axis = 0) - r_m[i]
        return np.where(diff &lt; 0, 0, 0.8 * diff)

    def annual_respiration(
            self, lai: Sequence, tmean: Sequence, years: Sequence
            ) -&gt; Iterable[Tuple[Sequence, Sequence, Sequence]]:
        &#39;&#39;&#39;
        Annual total maintenance respiration. Input datasets should have daily
        denominations and extend over one or more years.

        Parameters
        ----------
        lai : Sequence
            Leaf area index, daily, a (T x ...) array for T number of days
        tmean : Sequence
            Mean daily temperature (degrees C), a (T x ...) array for T number
            of days
        years : Sequence
            Sequence of integers indicating the year of each daily
            measurement, in order (e.g., [2015, 2015, ..., 2017]); a (T x ...)
            array for T number of days

        Returns
        -------
        tuple
            A 3-tuple of total annual (leaf, fine root, livewood) respiration
            with units of [g C m-2 year-1]
        &#39;&#39;&#39;
        assert lai.shape == years.shape,\
            &#39;LAI array should conform with &#34;years&#34; array&#39;
        assert tmean.shape == years.shape,\
            &#39;Mean temperature array should conform with &#34;years&#34; array&#39;
        r_leaf_daily, r_froot_daily = self.daily_respiration(lai, tmean)
        r_leaf, r_froot, r_livewood = [], [], []
        all_years = np.unique(years).tolist()
        all_years.sort()
        for i, each_year in enumerate(all_years):
            r_leaf.append(
                np.nansum(np.where(years == each_year, r_leaf_daily, 0),
                axis = 0))
            r_froot.append(
                np.nansum(np.where(years == each_year, r_froot_daily, 0),
                axis = 0))
            # Annual maximum leaf mass (kg C) converted to livewood mass
            #   by allometric relation (livewood_leaf_ratio)
            livewood_mass = (np.nanmax(
                    np.where(years == each_year, lai, np.nan), axis = 0
                ) / self.SLA) * self.livewood_leaf_ratio
            # Livewood maintenance respiration (g C day-1), converted from
            #   (kg C day-1), as the product of livewood_mass, base
            #   respiration rate (livewood_mr_base), and annual sum of the
            #   maint. respiration term (Q10), see Equation 1.10, User&#39;s Guide
            # NOTE: &#34;livewood_mr_base&#34; is denominated in days
            #   (kg C kg C-1 day-1) but that&#39;s okay because we took the annual
            #   sum of the Q10 respiration, essentially multipling by ~365
            rl = 1e3 * livewood_mass * self.livewood_mr_base *\
                np.power(self.Q10_livewood, (tmean - 20) / 10).sum(axis = 0)
            # For consistency with other respiration components, livewood
            #   respiration should be zero, not NaN, when no respiration
            r_livewood.append(np.where(np.isnan(rl), 0, rl))
        return (np.stack(r_leaf), np.stack(r_froot), np.vstack(r_livewood))

    def daily_gpp(
            self, fpar: Number, tmin: Number, vpd: Number,
            par: Number) -&gt; Number:
        r&#39;&#39;&#39;
        Daily gross primary productivity (GPP).

        $$
        \mathrm{GPP} = \varepsilon\times f(T_{min})\times f(V)\times
            [\mathrm{PAR}]\times [\mathrm{fPAR}]
        $$

        Where \(T_{min}\) is the minimum daily temperature, \(V\) is the
        daytime vapor pressure deficit (VPD), PAR is daily photosynthetically
        active radiation, fPAR is the fraction of PAR absorbed by the canopy,
        and \(\varepsilon\) is the intrinsic (or maximum) light-use efficiency.

        Parameters
        ----------
        fpar : int or float or numpy.ndarray
            Fraction of PAR intercepted by the canopy [0, 1]
        tmin : int or float or numpy.ndarray
            Daily minimum temperature (degrees C)
        vpd : int or float or numpy.ndarray
            Daytime vapor pressure deficit (Pa)
        par : int or float or numpy.ndarray
            Daily photosynthetically active radation (MJ m-2 day-1)

        Returns
        -------
        int or float or numpy.ndarray
            Daily GPP flux in [g C m-2 day-1]
        &#39;&#39;&#39;
        return 1e3 * self.lue(tmin, vpd) * fpar * par

    def daily_respiration(
            self, lai: Number, tmean: Number
            ) -&gt; Iterable[Tuple[Number, Number]]:
        r&#39;&#39;&#39;
        Daily maintenance respiration for leaves and fine roots.

        Maintenance respiration, \(r_m\), for leaves or fine roots is given:

        $$
        r_m = m \times r_0 \times q^{\frac{T - 20}{10}}
        $$

        Where \(m\) is either the leaf mass or fine root mass; \(r_0\) is the rate
        of maintenance respiration per unit leaf carbon (per day, at 20
        degrees C); and \(q\) is the Q10 factor.

        NOTE: For fine roots and live wood, Q10 is a constant value of 2.0.
        For leaves, the temperature-acclimated Q10 equation of Tjoelker et al.
        (2001, Global Change Biology) is used:

        $$
        Q_{10} = 3.22 - 0.046 * T_{avg}
        $$

        The &#34;net photosynthesis&#34; quantity in MOD17, even though it is a bit
        misleading (it does not account for growth respiration and livewood
        \(r_m\) can then be calculated as GPP less the maintenance respiration
        of leaves and fine roots:

        $$
        P_{net} = [\mathrm{GPP}] - r_{leaf} - r_{root}
        $$

        Parameters
        ----------
        lai : float or numpy.ndarray
            Leaf area index, daily
        tmean : float or numpy.ndarray
            Mean daily temperature (degrees C)

        Returns
        -------
        tuple
            2-element tuple of (leaf respiration, fine root respiration) in
            units of [g C m-2 day-1]
        &#39;&#39;&#39;
        # Leaf mass, fine root mass (Eq 1.4, 1.5 in MOD17 User Guide)
        leaf_mass = lai / self.SLA
        froot_mass = leaf_mass * self.froot_leaf_ratio
        # NOTE: Q10 calculated differently depending on the component
        _exp = (tmean - 20) / 10 # Equations 1.6 and 1.7
        q10_leaf = np.power(3.22 - 0.046 * tmean, _exp) # Equation 1.11
        q10_froot = np.power(self.Q10_froot, _exp)
        # NOTE: Converting from [kg C] to [g C] via *1e3
        r_leaf = 1e3 * leaf_mass * self.leaf_mr_base * q10_leaf
        r_froot = 1e3 * froot_mass * self.froot_mr_base * q10_froot
        return (r_leaf, r_froot)

    def daily_net_photosynthesis(
            self, fpar: Number, tmin: Number, vpd: Number, par: Number,
            lai: Number, tmean: Number) -&gt; Number:
        &#39;&#39;&#39;
        Daily net photosynthesis (&#34;PSNet&#34;). See:

        - `MOD17.daily_gpp()`
        - `MOD17.daily_respiration()`

        Parameters
        ----------
        fpar : int or float or numpy.ndarray
            Fraction of PAR intercepted by the canopy [0, 1]
        tmin : int or float or numpy.ndarray
            Daily minimum temperature (degrees C)
        vpd : int or float or numpy.ndarray
            Daytime vapor pressure deficit (Pa)
        par : int or float or numpy.ndarray
            Daily photosynthetically active radation (MJ m-2 day-1)
        lai : float or numpy.ndarray
            Leaf area index, daily
        tmean : float or numpy.ndarray
            Mean daily temperature (degrees C)
        &#39;&#39;&#39;
        gpp = self.daily_gpp(fpar, tmin, vpd, par)
        r_leaf, r_froot = self.daily_respiration(lai, tmean)
        # See MOD17 User Gudie, Equation 1.8
        return gpp - r_leaf - r_froot

    def lue(self, tmin: Number, vpd: Number) -&gt; Number:
        &#39;&#39;&#39;
        The instantaneous light-use efficiency (LUE), reduced by environmental
        stressors (low minimum temperature, high VPD) from the maximum LUE.

        Parameters
        ----------
        tmin : int or float or numpy.ndarray
        vpd : int or float or numpy.ndarray

        Returns
        -------
        float or numpy.ndarray
        &#39;&#39;&#39;
        return self.LUE_max * self.tmin_scalar(tmin) * self.vpd_scalar(vpd)

    def tmin_scalar(self, x: Number) -&gt; Number:
        &#39;&#39;&#39;
        Parameters
        ----------
        x : int or float or numpy.ndarray
            Minimum temperature (deg C)

        Returns
        -------
        int or float or numpy.ndarray
        &#39;&#39;&#39;
        return linear_constraint(self.tmin0, self.tmin1)(x)

    def vpd_scalar(self, x: Number) -&gt; Number:
        &#39;&#39;&#39;
        The environmental scalar for vapor pressure deficit (VPD).

        Parameters
        ----------
        x : int or float or numpy.ndarray
            Vapor pressure deficit (Pa)

        Returns
        -------
        int or float or numpy.ndarray
        &#39;&#39;&#39;
        return linear_constraint(self.vpd0, self.vpd1, form = &#39;reversed&#39;)(x)</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="mod17.MOD17.required_parameters"><code class="name">var <span class="ident">required_parameters</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="mod17.MOD17.par"><code class="name flex">
<span>def <span class="ident">par</span></span>(<span>sw_rad: numbers.Number, period_hrs: numbers.Number = 1) ‑> numbers.Number</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates daily total photosynthetically active radiation (PAR) from
(hourly) incoming short-wave radiation (SW_rad). PAR is assumed to
be 45% of SW_rad.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>swrad</code></strong> :&ensp;<code>int</code> or <code>float</code> or <code>numpy.ndarray</code></dt>
<dd>Incoming short-wave radiation (W m-2)</dd>
<dt><strong><code>period_hrs</code></strong> :&ensp;<code>int</code></dt>
<dd>Period over which radiation is measured, in hours (Default: 1)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code> or <code>float</code> or <code>numpy.ndarray</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def par(sw_rad: Number, period_hrs: Number = 1) -&gt; Number:
    &#39;&#39;&#39;
    Calculates daily total photosynthetically active radiation (PAR) from
    (hourly) incoming short-wave radiation (SW_rad). PAR is assumed to
    be 45% of SW_rad.

    Parameters
    ----------
    swrad : int or float or numpy.ndarray
        Incoming short-wave radiation (W m-2)
    period_hrs : int
        Period over which radiation is measured, in hours (Default: 1)

    Returns
    -------
    int or float or numpy.ndarray
    &#39;&#39;&#39;
    # Convert SW_rad from [W m-2] to [MJ m-2], then take 45%;
    #   3600 secs hr-1 times (1 MJ / 1e6 Joules) == 0.0036
    return 0.45 * (0.0036 * (24 / period_hrs) * sw_rad)</code></pre>
</details>
</dd>
<dt id="mod17.MOD17.vpd"><code class="name flex">
<span>def <span class="ident">vpd</span></span>(<span>qv10m: numbers.Number, pressure: numbers.Number, tmean: numbers.Number) ‑> numbers.Number</span>
</code></dt>
<dd>
<div class="desc"><p>Computes vapor pressure deficit (VPD) from surface meteorology.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>qv10m</code></strong> :&ensp;<code>int</code> or <code>float</code> or <code>numpy.ndarray</code></dt>
<dd>Water vapor mixing ratio at 10-meter height (Pa)</dd>
<dt><strong><code>pressure</code></strong> :&ensp;<code>int</code> or <code>float</code> or <code>numpy.ndarray</code></dt>
<dd>Atmospheric pressure (Pa)</dd>
<dt><strong><code>tmean</code></strong> :&ensp;<code>int</code> or <code>float</code> or <code>numpy.ndarray</code></dt>
<dd>Mean daytime temperature (degrees C)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code> or <code>float</code> or <code>numpy.ndarray</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def vpd(qv10m: Number, pressure: Number, tmean: Number) -&gt; Number:
    &#39;&#39;&#39;
    Computes vapor pressure deficit (VPD) from surface meteorology.

    Parameters
    ----------
    qv10m : int or float or numpy.ndarray
        Water vapor mixing ratio at 10-meter height (Pa)
    pressure : int or float or numpy.ndarray
        Atmospheric pressure (Pa)
    tmean : int or float or numpy.ndarray
        Mean daytime temperature (degrees C)

    Returns
    -------
    int or float or numpy.ndarray
    &#39;&#39;&#39;
    # Actual vapor pressure (Gates 1980, Biophysical Ecology, p.311)
    avp = (qv10m * pressure) / (0.622 + (0.379 * qv10m))
    # Saturation vapor pressure (similar to FAO formula)
    svp = 610.7 * np.exp((17.38 * tmean) / (239 + tmean))
    return svp - avp</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="mod17.MOD17.annual_npp"><code class="name flex">
<span>def <span class="ident">annual_npp</span></span>(<span>self, fpar: Sequence[+T_co], tmin: Sequence[+T_co], vpd: Sequence[+T_co], par: Sequence[+T_co], lai: Sequence[+T_co], tmean: Sequence[+T_co], years: Sequence[+T_co]) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Annual net primary productivity (NPP).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>fpar</code></strong> :&ensp;<code>Sequence</code></dt>
<dd>Fraction of PAR intercepted by the canopy [0, 1], a (T x &hellip;)
array for T number of days</dd>
<dt><strong><code>tmin</code></strong> :&ensp;<code>Sequence</code></dt>
<dd>Daily minimum temperature (degrees C), a (T x &hellip;) array for T
number of days</dd>
<dt><strong><code>vpd</code></strong> :&ensp;<code>Sequence</code></dt>
<dd>Daytime vapor pressure deficit (Pa), a (T x &hellip;) array for T
number of days</dd>
<dt><strong><code>par</code></strong> :&ensp;<code>Sequence</code></dt>
<dd>Daily photosynthetically active radation (MJ m-2 day-1)</dd>
<dt><strong><code>lai</code></strong> :&ensp;<code>Sequence</code></dt>
<dd>Leaf area index, daily, a (T x &hellip;) array for T number of days</dd>
<dt><strong><code>tmean</code></strong> :&ensp;<code>Sequence</code></dt>
<dd>Mean daily temperature (degrees C), a (T x &hellip;) array for T number
of days</dd>
<dt><strong><code>years</code></strong> :&ensp;<code>Sequence</code></dt>
<dd>Sequence of integers indicating the year of each daily
measurement, in order (e.g., [2015, 2015, &hellip;, 2017]); a (T x &hellip;)
array for T number of days</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>numpy.ndarray</code></dt>
<dd>Total annual NPP [g C m-2 year-1]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def annual_npp(
        self, fpar: Sequence, tmin: Sequence, vpd: Sequence,
        par: Sequence, lai: Sequence, tmean: Sequence, years: Sequence
        ) -&gt; np.ndarray:
    &#39;&#39;&#39;
    Annual net primary productivity (NPP).

    Parameters
    ----------
    fpar : Sequence
        Fraction of PAR intercepted by the canopy [0, 1], a (T x ...)
        array for T number of days
    tmin : Sequence
        Daily minimum temperature (degrees C), a (T x ...) array for T
        number of days
    vpd : Sequence
        Daytime vapor pressure deficit (Pa), a (T x ...) array for T
        number of days
    par : Sequence
        Daily photosynthetically active radation (MJ m-2 day-1)
    lai : Sequence
        Leaf area index, daily, a (T x ...) array for T number of days
    tmean : Sequence
        Mean daily temperature (degrees C), a (T x ...) array for T number
        of days
    years : Sequence
        Sequence of integers indicating the year of each daily
        measurement, in order (e.g., [2015, 2015, ..., 2017]); a (T x ...)
        array for T number of days

    Returns
    -------
    numpy.ndarray
        Total annual NPP [g C m-2 year-1]
    &#39;&#39;&#39;
    r_leaf, r_froot, r_livewood = self.annual_respiration(
        lai, tmean, years)
    r_m = r_leaf + r_froot + r_livewood
    gpp = self.daily_gpp(fpar, tmin, vpd, par)
    diff = np.empty(r_m.shape)
    all_years = np.unique(years).tolist()
    for i, each_year in enumerate(all_years):
        # GPP - R_M
        diff[i] = np.where(years == each_year, gpp, 0).sum(axis = 0) - r_m[i]
    return np.where(diff &lt; 0, 0, 0.8 * diff)</code></pre>
</details>
</dd>
<dt id="mod17.MOD17.annual_respiration"><code class="name flex">
<span>def <span class="ident">annual_respiration</span></span>(<span>self, lai: Sequence[+T_co], tmean: Sequence[+T_co], years: Sequence[+T_co]) ‑> Iterable[Tuple[Sequence[+T_co], Sequence[+T_co], Sequence[+T_co]]]</span>
</code></dt>
<dd>
<div class="desc"><p>Annual total maintenance respiration. Input datasets should have daily
denominations and extend over one or more years.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>lai</code></strong> :&ensp;<code>Sequence</code></dt>
<dd>Leaf area index, daily, a (T x &hellip;) array for T number of days</dd>
<dt><strong><code>tmean</code></strong> :&ensp;<code>Sequence</code></dt>
<dd>Mean daily temperature (degrees C), a (T x &hellip;) array for T number
of days</dd>
<dt><strong><code>years</code></strong> :&ensp;<code>Sequence</code></dt>
<dd>Sequence of integers indicating the year of each daily
measurement, in order (e.g., [2015, 2015, &hellip;, 2017]); a (T x &hellip;)
array for T number of days</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>A 3-tuple of total annual (leaf, fine root, livewood) respiration
with units of [g C m-2 year-1]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def annual_respiration(
        self, lai: Sequence, tmean: Sequence, years: Sequence
        ) -&gt; Iterable[Tuple[Sequence, Sequence, Sequence]]:
    &#39;&#39;&#39;
    Annual total maintenance respiration. Input datasets should have daily
    denominations and extend over one or more years.

    Parameters
    ----------
    lai : Sequence
        Leaf area index, daily, a (T x ...) array for T number of days
    tmean : Sequence
        Mean daily temperature (degrees C), a (T x ...) array for T number
        of days
    years : Sequence
        Sequence of integers indicating the year of each daily
        measurement, in order (e.g., [2015, 2015, ..., 2017]); a (T x ...)
        array for T number of days

    Returns
    -------
    tuple
        A 3-tuple of total annual (leaf, fine root, livewood) respiration
        with units of [g C m-2 year-1]
    &#39;&#39;&#39;
    assert lai.shape == years.shape,\
        &#39;LAI array should conform with &#34;years&#34; array&#39;
    assert tmean.shape == years.shape,\
        &#39;Mean temperature array should conform with &#34;years&#34; array&#39;
    r_leaf_daily, r_froot_daily = self.daily_respiration(lai, tmean)
    r_leaf, r_froot, r_livewood = [], [], []
    all_years = np.unique(years).tolist()
    all_years.sort()
    for i, each_year in enumerate(all_years):
        r_leaf.append(
            np.nansum(np.where(years == each_year, r_leaf_daily, 0),
            axis = 0))
        r_froot.append(
            np.nansum(np.where(years == each_year, r_froot_daily, 0),
            axis = 0))
        # Annual maximum leaf mass (kg C) converted to livewood mass
        #   by allometric relation (livewood_leaf_ratio)
        livewood_mass = (np.nanmax(
                np.where(years == each_year, lai, np.nan), axis = 0
            ) / self.SLA) * self.livewood_leaf_ratio
        # Livewood maintenance respiration (g C day-1), converted from
        #   (kg C day-1), as the product of livewood_mass, base
        #   respiration rate (livewood_mr_base), and annual sum of the
        #   maint. respiration term (Q10), see Equation 1.10, User&#39;s Guide
        # NOTE: &#34;livewood_mr_base&#34; is denominated in days
        #   (kg C kg C-1 day-1) but that&#39;s okay because we took the annual
        #   sum of the Q10 respiration, essentially multipling by ~365
        rl = 1e3 * livewood_mass * self.livewood_mr_base *\
            np.power(self.Q10_livewood, (tmean - 20) / 10).sum(axis = 0)
        # For consistency with other respiration components, livewood
        #   respiration should be zero, not NaN, when no respiration
        r_livewood.append(np.where(np.isnan(rl), 0, rl))
    return (np.stack(r_leaf), np.stack(r_froot), np.vstack(r_livewood))</code></pre>
</details>
</dd>
<dt id="mod17.MOD17.daily_gpp"><code class="name flex">
<span>def <span class="ident">daily_gpp</span></span>(<span>self, fpar: numbers.Number, tmin: numbers.Number, vpd: numbers.Number, par: numbers.Number) ‑> numbers.Number</span>
</code></dt>
<dd>
<div class="desc"><p>Daily gross primary productivity (GPP).</p>
<p><span><span class="MathJax_Preview">
\mathrm{GPP} = \varepsilon\times f(T_{min})\times f(V)\times
[\mathrm{PAR}]\times [\mathrm{fPAR}]
</span><script type="math/tex; mode=display">
\mathrm{GPP} = \varepsilon\times f(T_{min})\times f(V)\times
[\mathrm{PAR}]\times [\mathrm{fPAR}]
</script></span></p>
<p>Where <span><span class="MathJax_Preview">T_{min}</span><script type="math/tex">T_{min}</script></span> is the minimum daily temperature, <span><span class="MathJax_Preview">V</span><script type="math/tex">V</script></span> is the
daytime vapor pressure deficit (VPD), PAR is daily photosynthetically
active radiation, fPAR is the fraction of PAR absorbed by the canopy,
and <span><span class="MathJax_Preview">\varepsilon</span><script type="math/tex">\varepsilon</script></span> is the intrinsic (or maximum) light-use efficiency.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>fpar</code></strong> :&ensp;<code>int</code> or <code>float</code> or <code>numpy.ndarray</code></dt>
<dd>Fraction of PAR intercepted by the canopy [0, 1]</dd>
<dt><strong><code>tmin</code></strong> :&ensp;<code>int</code> or <code>float</code> or <code>numpy.ndarray</code></dt>
<dd>Daily minimum temperature (degrees C)</dd>
<dt><strong><code>vpd</code></strong> :&ensp;<code>int</code> or <code>float</code> or <code>numpy.ndarray</code></dt>
<dd>Daytime vapor pressure deficit (Pa)</dd>
<dt><strong><code>par</code></strong> :&ensp;<code>int</code> or <code>float</code> or <code>numpy.ndarray</code></dt>
<dd>Daily photosynthetically active radation (MJ m-2 day-1)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code> or <code>float</code> or <code>numpy.ndarray</code></dt>
<dd>Daily GPP flux in [g C m-2 day-1]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def daily_gpp(
        self, fpar: Number, tmin: Number, vpd: Number,
        par: Number) -&gt; Number:
    r&#39;&#39;&#39;
    Daily gross primary productivity (GPP).

    $$
    \mathrm{GPP} = \varepsilon\times f(T_{min})\times f(V)\times
        [\mathrm{PAR}]\times [\mathrm{fPAR}]
    $$

    Where \(T_{min}\) is the minimum daily temperature, \(V\) is the
    daytime vapor pressure deficit (VPD), PAR is daily photosynthetically
    active radiation, fPAR is the fraction of PAR absorbed by the canopy,
    and \(\varepsilon\) is the intrinsic (or maximum) light-use efficiency.

    Parameters
    ----------
    fpar : int or float or numpy.ndarray
        Fraction of PAR intercepted by the canopy [0, 1]
    tmin : int or float or numpy.ndarray
        Daily minimum temperature (degrees C)
    vpd : int or float or numpy.ndarray
        Daytime vapor pressure deficit (Pa)
    par : int or float or numpy.ndarray
        Daily photosynthetically active radation (MJ m-2 day-1)

    Returns
    -------
    int or float or numpy.ndarray
        Daily GPP flux in [g C m-2 day-1]
    &#39;&#39;&#39;
    return 1e3 * self.lue(tmin, vpd) * fpar * par</code></pre>
</details>
</dd>
<dt id="mod17.MOD17.daily_net_photosynthesis"><code class="name flex">
<span>def <span class="ident">daily_net_photosynthesis</span></span>(<span>self, fpar: numbers.Number, tmin: numbers.Number, vpd: numbers.Number, par: numbers.Number, lai: numbers.Number, tmean: numbers.Number) ‑> numbers.Number</span>
</code></dt>
<dd>
<div class="desc"><p>Daily net photosynthesis ("PSNet"). See:</p>
<ul>
<li><code><a title="mod17.MOD17.daily_gpp" href="#mod17.MOD17.daily_gpp">MOD17.daily_gpp()</a></code></li>
<li><code><a title="mod17.MOD17.daily_respiration" href="#mod17.MOD17.daily_respiration">MOD17.daily_respiration()</a></code></li>
</ul>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>fpar</code></strong> :&ensp;<code>int</code> or <code>float</code> or <code>numpy.ndarray</code></dt>
<dd>Fraction of PAR intercepted by the canopy [0, 1]</dd>
<dt><strong><code>tmin</code></strong> :&ensp;<code>int</code> or <code>float</code> or <code>numpy.ndarray</code></dt>
<dd>Daily minimum temperature (degrees C)</dd>
<dt><strong><code>vpd</code></strong> :&ensp;<code>int</code> or <code>float</code> or <code>numpy.ndarray</code></dt>
<dd>Daytime vapor pressure deficit (Pa)</dd>
<dt><strong><code>par</code></strong> :&ensp;<code>int</code> or <code>float</code> or <code>numpy.ndarray</code></dt>
<dd>Daily photosynthetically active radation (MJ m-2 day-1)</dd>
<dt><strong><code>lai</code></strong> :&ensp;<code>float</code> or <code>numpy.ndarray</code></dt>
<dd>Leaf area index, daily</dd>
<dt><strong><code>tmean</code></strong> :&ensp;<code>float</code> or <code>numpy.ndarray</code></dt>
<dd>Mean daily temperature (degrees C)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def daily_net_photosynthesis(
        self, fpar: Number, tmin: Number, vpd: Number, par: Number,
        lai: Number, tmean: Number) -&gt; Number:
    &#39;&#39;&#39;
    Daily net photosynthesis (&#34;PSNet&#34;). See:

    - `MOD17.daily_gpp()`
    - `MOD17.daily_respiration()`

    Parameters
    ----------
    fpar : int or float or numpy.ndarray
        Fraction of PAR intercepted by the canopy [0, 1]
    tmin : int or float or numpy.ndarray
        Daily minimum temperature (degrees C)
    vpd : int or float or numpy.ndarray
        Daytime vapor pressure deficit (Pa)
    par : int or float or numpy.ndarray
        Daily photosynthetically active radation (MJ m-2 day-1)
    lai : float or numpy.ndarray
        Leaf area index, daily
    tmean : float or numpy.ndarray
        Mean daily temperature (degrees C)
    &#39;&#39;&#39;
    gpp = self.daily_gpp(fpar, tmin, vpd, par)
    r_leaf, r_froot = self.daily_respiration(lai, tmean)
    # See MOD17 User Gudie, Equation 1.8
    return gpp - r_leaf - r_froot</code></pre>
</details>
</dd>
<dt id="mod17.MOD17.daily_respiration"><code class="name flex">
<span>def <span class="ident">daily_respiration</span></span>(<span>self, lai: numbers.Number, tmean: numbers.Number) ‑> Iterable[Tuple[numbers.Number, numbers.Number]]</span>
</code></dt>
<dd>
<div class="desc"><p>Daily maintenance respiration for leaves and fine roots.</p>
<p>Maintenance respiration, <span><span class="MathJax_Preview">r_m</span><script type="math/tex">r_m</script></span>, for leaves or fine roots is given:</p>
<p><span><span class="MathJax_Preview">
r_m = m \times r_0 \times q^{\frac{T - 20}{10}}
</span><script type="math/tex; mode=display">
r_m = m \times r_0 \times q^{\frac{T - 20}{10}}
</script></span></p>
<p>Where <span><span class="MathJax_Preview">m</span><script type="math/tex">m</script></span> is either the leaf mass or fine root mass; <span><span class="MathJax_Preview">r_0</span><script type="math/tex">r_0</script></span> is the rate
of maintenance respiration per unit leaf carbon (per day, at 20
degrees C); and <span><span class="MathJax_Preview">q</span><script type="math/tex">q</script></span> is the Q10 factor.</p>
<p>NOTE: For fine roots and live wood, Q10 is a constant value of 2.0.
For leaves, the temperature-acclimated Q10 equation of Tjoelker et al.
(2001, Global Change Biology) is used:</p>
<p><span><span class="MathJax_Preview">
Q_{10} = 3.22 - 0.046 * T_{avg}
</span><script type="math/tex; mode=display">
Q_{10} = 3.22 - 0.046 * T_{avg}
</script></span></p>
<p>The "net photosynthesis" quantity in MOD17, even though it is a bit
misleading (it does not account for growth respiration and livewood
<span><span class="MathJax_Preview">r_m</span><script type="math/tex">r_m</script></span> can then be calculated as GPP less the maintenance respiration
of leaves and fine roots:</p>
<p><span><span class="MathJax_Preview">
P_{net} = [\mathrm{GPP}] - r_{leaf} - r_{root}
</span><script type="math/tex; mode=display">
P_{net} = [\mathrm{GPP}] - r_{leaf} - r_{root}
</script></span></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>lai</code></strong> :&ensp;<code>float</code> or <code>numpy.ndarray</code></dt>
<dd>Leaf area index, daily</dd>
<dt><strong><code>tmean</code></strong> :&ensp;<code>float</code> or <code>numpy.ndarray</code></dt>
<dd>Mean daily temperature (degrees C)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>2-element tuple of (leaf respiration, fine root respiration) in
units of [g C m-2 day-1]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def daily_respiration(
        self, lai: Number, tmean: Number
        ) -&gt; Iterable[Tuple[Number, Number]]:
    r&#39;&#39;&#39;
    Daily maintenance respiration for leaves and fine roots.

    Maintenance respiration, \(r_m\), for leaves or fine roots is given:

    $$
    r_m = m \times r_0 \times q^{\frac{T - 20}{10}}
    $$

    Where \(m\) is either the leaf mass or fine root mass; \(r_0\) is the rate
    of maintenance respiration per unit leaf carbon (per day, at 20
    degrees C); and \(q\) is the Q10 factor.

    NOTE: For fine roots and live wood, Q10 is a constant value of 2.0.
    For leaves, the temperature-acclimated Q10 equation of Tjoelker et al.
    (2001, Global Change Biology) is used:

    $$
    Q_{10} = 3.22 - 0.046 * T_{avg}
    $$

    The &#34;net photosynthesis&#34; quantity in MOD17, even though it is a bit
    misleading (it does not account for growth respiration and livewood
    \(r_m\) can then be calculated as GPP less the maintenance respiration
    of leaves and fine roots:

    $$
    P_{net} = [\mathrm{GPP}] - r_{leaf} - r_{root}
    $$

    Parameters
    ----------
    lai : float or numpy.ndarray
        Leaf area index, daily
    tmean : float or numpy.ndarray
        Mean daily temperature (degrees C)

    Returns
    -------
    tuple
        2-element tuple of (leaf respiration, fine root respiration) in
        units of [g C m-2 day-1]
    &#39;&#39;&#39;
    # Leaf mass, fine root mass (Eq 1.4, 1.5 in MOD17 User Guide)
    leaf_mass = lai / self.SLA
    froot_mass = leaf_mass * self.froot_leaf_ratio
    # NOTE: Q10 calculated differently depending on the component
    _exp = (tmean - 20) / 10 # Equations 1.6 and 1.7
    q10_leaf = np.power(3.22 - 0.046 * tmean, _exp) # Equation 1.11
    q10_froot = np.power(self.Q10_froot, _exp)
    # NOTE: Converting from [kg C] to [g C] via *1e3
    r_leaf = 1e3 * leaf_mass * self.leaf_mr_base * q10_leaf
    r_froot = 1e3 * froot_mass * self.froot_mr_base * q10_froot
    return (r_leaf, r_froot)</code></pre>
</details>
</dd>
<dt id="mod17.MOD17.lue"><code class="name flex">
<span>def <span class="ident">lue</span></span>(<span>self, tmin: numbers.Number, vpd: numbers.Number) ‑> numbers.Number</span>
</code></dt>
<dd>
<div class="desc"><p>The instantaneous light-use efficiency (LUE), reduced by environmental
stressors (low minimum temperature, high VPD) from the maximum LUE.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>tmin</code></strong> :&ensp;<code>int</code> or <code>float</code> or <code>numpy.ndarray</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>vpd</code></strong> :&ensp;<code>int</code> or <code>float</code> or <code>numpy.ndarray</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code> or <code>numpy.ndarray</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lue(self, tmin: Number, vpd: Number) -&gt; Number:
    &#39;&#39;&#39;
    The instantaneous light-use efficiency (LUE), reduced by environmental
    stressors (low minimum temperature, high VPD) from the maximum LUE.

    Parameters
    ----------
    tmin : int or float or numpy.ndarray
    vpd : int or float or numpy.ndarray

    Returns
    -------
    float or numpy.ndarray
    &#39;&#39;&#39;
    return self.LUE_max * self.tmin_scalar(tmin) * self.vpd_scalar(vpd)</code></pre>
</details>
</dd>
<dt id="mod17.MOD17.tmin_scalar"><code class="name flex">
<span>def <span class="ident">tmin_scalar</span></span>(<span>self, x: numbers.Number) ‑> numbers.Number</span>
</code></dt>
<dd>
<div class="desc"><h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>int</code> or <code>float</code> or <code>numpy.ndarray</code></dt>
<dd>Minimum temperature (deg C)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code> or <code>float</code> or <code>numpy.ndarray</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tmin_scalar(self, x: Number) -&gt; Number:
    &#39;&#39;&#39;
    Parameters
    ----------
    x : int or float or numpy.ndarray
        Minimum temperature (deg C)

    Returns
    -------
    int or float or numpy.ndarray
    &#39;&#39;&#39;
    return linear_constraint(self.tmin0, self.tmin1)(x)</code></pre>
</details>
</dd>
<dt id="mod17.MOD17.vpd_scalar"><code class="name flex">
<span>def <span class="ident">vpd_scalar</span></span>(<span>self, x: numbers.Number) ‑> numbers.Number</span>
</code></dt>
<dd>
<div class="desc"><p>The environmental scalar for vapor pressure deficit (VPD).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>int</code> or <code>float</code> or <code>numpy.ndarray</code></dt>
<dd>Vapor pressure deficit (Pa)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code> or <code>float</code> or <code>numpy.ndarray</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vpd_scalar(self, x: Number) -&gt; Number:
    &#39;&#39;&#39;
    The environmental scalar for vapor pressure deficit (VPD).

    Parameters
    ----------
    x : int or float or numpy.ndarray
        Vapor pressure deficit (Pa)

    Returns
    -------
    int or float or numpy.ndarray
    &#39;&#39;&#39;
    return linear_constraint(self.vpd0, self.vpd1, form = &#39;reversed&#39;)(x)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="mod17.calibration" href="calibration.html">mod17.calibration</a></code></li>
<li><code><a title="mod17.science" href="science.html">mod17.science</a></code></li>
<li><code><a title="mod17.sensitivity" href="sensitivity.html">mod17.sensitivity</a></code></li>
<li><code><a title="mod17.srs" href="srs.html">mod17.srs</a></code></li>
<li><code><a title="mod17.utils" href="utils.html">mod17.utils</a></code></li>
<li><code><a title="mod17.viirs" href="viirs.html">mod17.viirs</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="mod17.linear_constraint" href="#mod17.linear_constraint">linear_constraint</a></code></li>
<li><code><a title="mod17.suppress_warnings" href="#mod17.suppress_warnings">suppress_warnings</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="mod17.MOD17" href="#mod17.MOD17">MOD17</a></code></h4>
<ul class="">
<li><code><a title="mod17.MOD17.annual_npp" href="#mod17.MOD17.annual_npp">annual_npp</a></code></li>
<li><code><a title="mod17.MOD17.annual_respiration" href="#mod17.MOD17.annual_respiration">annual_respiration</a></code></li>
<li><code><a title="mod17.MOD17.daily_gpp" href="#mod17.MOD17.daily_gpp">daily_gpp</a></code></li>
<li><code><a title="mod17.MOD17.daily_net_photosynthesis" href="#mod17.MOD17.daily_net_photosynthesis">daily_net_photosynthesis</a></code></li>
<li><code><a title="mod17.MOD17.daily_respiration" href="#mod17.MOD17.daily_respiration">daily_respiration</a></code></li>
<li><code><a title="mod17.MOD17.lue" href="#mod17.MOD17.lue">lue</a></code></li>
<li><code><a title="mod17.MOD17.par" href="#mod17.MOD17.par">par</a></code></li>
<li><code><a title="mod17.MOD17.required_parameters" href="#mod17.MOD17.required_parameters">required_parameters</a></code></li>
<li><code><a title="mod17.MOD17.tmin_scalar" href="#mod17.MOD17.tmin_scalar">tmin_scalar</a></code></li>
<li><code><a title="mod17.MOD17.vpd" href="#mod17.MOD17.vpd">vpd</a></code></li>
<li><code><a title="mod17.MOD17.vpd_scalar" href="#mod17.MOD17.vpd_scalar">vpd_scalar</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>